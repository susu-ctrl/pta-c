//算法主要分为两部分：一部分是处理整数中完整的70的倍数，另一部分是处理不足70的余数部分。
//对于剩余数部分，算法通过遍历每个数，检查其是否是7的倍数或以7结尾，如果是，则计数加1。
//根据观察规律可知，每70个数字就需要击掌16次，我们只需要计算出有多少个70再对余下的数字。

#define _CRT_SECURE_NO_WARNINGS  
#include <stdio.h>  

int main() {
    int n, c=0; // n为用户输入的整数，c用于计数包含的“7”的数量,初始化计数器c为0
       
    scanf("%d", &n); // 读取用户输入的整数n  

    // 计算n中包含的完整的70的倍数所带来的"7"的数量，并加到计数器c上  
    // 这里假设每70个数中包含16个“7”，可能是基于某种特定规则或统计  
    c += (n / 70) * 16;

    // 计算n除以70的余数，只对余数部分进行后续处理  
    n %= 70;

    // 遍历n除以70的余数范围内的每一个数  
    for (int i = 1; i <= n; ++i) {
        // 只需要判断是否是7的倍数或者以7结尾  
        if (i % 7 == 0 || i % 10 == 7) {
            c++;
        }
    }

    // 输出最终计数器c的值，即n中包含的“7”的总数量  
    printf("%d", c);

    return 0; // 程序正常结束  
}
